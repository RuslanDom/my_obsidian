# Документация по Flask

https://docs-python.ru/packages/veb-frejmvork-flask-python/
https://flask.palletsprojects.com/en/stable/quickstart/
# LINUX

# Быстрый старт

```python
from flask import Flask  
  
app = Flask(__name__)  
  
@app.route("/")  
def start_app():  
    return "Start working program"  

  
if __name__ == "__main__":  
    app.config["WTF_CSRF_ENABLED"] = False  
    app.run(debug=True)
```

1. Сначала мы импортировали класс Flask. Экземпляр этого класса и будет вашим WSGI-приложением.
2. Далее мы создаём экземпляр этого класса. 
3. Далее, мы используем декоратор route(), чтобы сказать Flask, какой из URL должен запускать нашу функцию.

Если у вас отключена опция debug или вы доверяете пользователям в сети, вы можете сделать сервер публично доступным, просто изменив вызов метода run() таким
вот образом:
```python
app.run(host='0.0.0.0')
```

# Маршрутизация
Как вы увидели ранее, декоратор route() используется для привязки функции к
URL.
```python
@app.route('/')
def index():
	return 'Index Page'


@app.route('/hello')
def hello():
	return 'Hello World'
```

Чтобы добавлять к адресу URL переменные части, можно эти особые части выделить как <variable_name>. Затем подобные части передаются в вашу функцию в
качестве аргумента - в виде ключевого слова. Также может быть использован конвертер - с помощью задания правила следующего вида <converter:variable_name>
```python
@app.route("/user/<username>")  
def user_hello(username: str):  
    return "User name is %s" % username  
  
@app.route("/post/<post_id>")  
def get_post(post_id: int):  
    return "User ID %d" % post_id  
```

## Существуют следующие конвертеры:

| int | принимаются целочисленные значения
| float | как и int, только значения с плавающей точкой
| path | подобно поведению по умолчанию, но допускаются слэши

## Уникальные URL / Перенаправления
Правила для URL, работающие в Flask, основаны на модуле маршрутизации
Werkzeug. Этот модуль реализован в соответствие с идеей обеспечения красивых и
уникальных URL-адресов на основе исторически попавшего в обиход - из поведения
Apache и более ранних HTTP серверов. 
Хоть они и выглядят довольно похожими, есть разница в использовании слэша в
определении URL. В первом случае, канонический URL имеет завершающую часть
projects со слэшем в конце. В этом смысле он похож на папку в файловой системе. В
данном случае, при доступе к URL без слэша, Flask перенаправит к каноническому
URL с завершающим слэшем.
```python
@app.route('/projects/')  
def projects():  
    return 'The project page'  
    
@app.route('/about')  
def about():  
    return 'The about page'  
```

## Генерация URL
Flask может искать соответствия в URL и может  их генерировать. Для построения URL для специфической функции, вы можете использовать функцию url_for(). В качестве первого аргумента она принимает имя функции, кроме того она принимает ряд именованных аргументов, каждый из которых
соответствует переменной части правила для URL. Неизвестные переменные части
добавляются к URL в качестве параметров запроса.
```python
from flask import Flask, url_for

app = Flask(__name__)

@app.route("/")  
def index():  
    pass  
  
@app.route("/login")  
def login():  
    pass  
  
@app.route("/user/<username>")  
def profile(username):  
    pass  

with app.test_request_context():  
    print(url_for("index"))  
    print(url_for("login"))  
    print(url_for("login", next='/'))  
    print(url_for("profile", username='Buddy Man'))
```

 ```
RESULT:  
/  
/login  
/login?next=/  
 /user/Buddy%20Man
```

Зачем формировать URL через url_for()
4. По сравнению с жёстким заданием URL внутри кода обратный порядок часто является более наглядным. Более того, он позволяет менять URL за один шаг, и забыть про необходимость изменять URL повсюду. 
5. Построение URL будет прозрачно для вас осуществлять экранирование специальных символов и данных Unicode, так что вам не придётся отдельно иметь с ними дела. 
6. Если ваше приложение размещено не в корневой папке URL root (а, скажем, в /myapplication вместо /), данную ситуацию нужным для вас образом обработает функция url_for().

# Методы HTTP

HTTP (протокол, на котором общаются веб-приложения) может использовать различные методы для доступа к URL-адресам. По умолчанию, route отвечает лишь на
запросы типа GET, но это можно изменить, снабдив декоратор route() аргументом
methods.
```python
from flask import request

@app.route('/login', methods=['GET', 'POST'])
def login():
	if request.method == 'POST':
		do_the_login()
	else:
		show_the_login_form()
```
Если присутствует метод GET, то автоматически будет добавлен и HEAD. Вам не
придётся иметь с ним дело. Также, при этом можно быть уверенным, что запросы
HEAD будут обработаны в соответствии с требованиями HTTP RFC (документ с
описанием протокола HTTP), так что вам не требуется ничего знать об этой части спецификации HTTP. Кроме того, для вас будет
автоматически реализован метод OPTIONS автоматически.

***HTTP-метод (также часто называемый командой) сообщает серверу, что хочет сделать клиент с запрашиваемой страницей.***  
Очень распространены Следующие методы:
- ***GET*** Браузер говорит серверу, чтобы он просто получил информацию, хранимую на этой странице, и отослал её. Возможно, это самый распространённый метод.
- ***HEAD*** Браузер просит сервер получить информацию, но его интересует только заголовки, а не содержимое страницы. Приложение предполагает обработать их так же, как если бы был получен запрос GET, но без доставки фактического содержимого. В Flask, вам вовсе не требуется иметь дело с этим методом, так как нижележащая библиотека Werkzeug сделает всё за вас.
- ***POST*** Браузер говорит серверу, что он хочет сообщить этому URL некоторую новую информацию, и что сервер должен убедиться, что данные сохранены и сохранены в единожды. Обычно, аналогичным образом происходит передача из HTML форм на сервер данных.
- ***PUT*** Похоже на POST, только сервер может вызвать процедуру сохранения несколько раз, перезаписывая старые значения более одного раза. Здесь вы можете спросить, зачем это нужно, и есть несколько веских причин, чтобы делать это подобным образом. Предположим, во время передачи произошла потеря соединения: в этой ситуации система между браузером и сервером, ничего не нарушая, может совершенно спокойно получить запрос во второй раз. С POST такое было бы невозможно, потому что он может быть вызван только один раз.
- ***DELETE*** Удалить информацию, расположенную в указанном месте.
- ***OPTIONS*** Обеспечивает быстрый способ выяснения клиентом поддерживаемых для данного URL методов. Начиная с Flask 0.6, это работает для вас автоматически.

# Статические файлы
Динамические веб-приложения также нуждаются и в статических файлах. Обычно, именно из них берутся файлы CSS и JavaScript. В идеале ваш веб-сервер уже
сконфигурирован так, чтобы обслуживать их для вас, однако в ходе разработке это
также может делать и сам Flask. Просто создайте внутри вашего пакета или модуля
папку с названием static, и она будет доступна из приложения как /static.
```python
url_for('static', filename='style.css')
```

# Визуализация шаблонов
Генерация HTML из Python - невесёлое и на самом деле довольно сложное занятие,
так как вам необходимо самостоятельно заботиться о безопасности приложения, производя для HTML обработку специальных последовательностей (escaping). Поэтому
внутри Flask уже автоматически преднастроен шаблонизатор Jinja2.
Для визуализации шаблона вы можете использовать метод render_template(). Всё,
что вам необходимо - это указать имя шаблона, а также переменные в виде именованных аргументов, которые вы хотите передать движку обработки шаблонов
```python
from flask import render_template

@app.route('/hello/')
@app.route('/hello/<name>')
def hello(name=None):
	return render_template('hello.html', name=name)
```

Flask будет искать шаблоны в папке templates. Поэтому, если ваше приложение выполнено в виде модуля, эта папка будет рядом с модулем, а если в виде пакета, она
будет внутри вашего пакета

Первый случай - модуль:
```
/application.py
/templates
	/hello.html
```

Второй случай - пакет:
```
/application
	/__init__.py
	/templates
		/hello.html
```

При работе с шаблонами вы можете использовать всю мощь Jinja2.
```
<!doctype html>
<title>Hello from Flask</title>
{% if name %}
<h1>Hello {{ name }}!</h1>
{% else %}
<h1>Hello World!</h1>
{% endif %}
```

Также, внутри шаблонов вы имеете доступ к объектам request, session и g , а также
к функции get_flashed_messages(). Шаблоны особенно полезны при использовании наследования. Проще говоря, наследование шаблонов позволяет разместить определённые элементы (такие, как заголовки, элементы навигации и «подвал» страницы) на каждой странице.

# Тестирование модулей

Для тестирования модулей является использование менеджера - контекстов test_request_context().
В сочетании с оператором with этот менеджер свяжет тестовый запрос так, что вы
сможете с ним взаимодействовать.
```python
from flask import request

with app.test_request_context('/hello', method='POST'):
	# теперь, и до конца блока with, вы можете что-либо делать
	# с контекстом, например, вызывать простые assert-ы:
	assert request.path == '/hello'
	assert request.method == 'POST'
```
Другая возможность - request_context() method:
```python
from flask import request

with app.request_context(environ):
	assert request.method == 'POST'
```

# Объект запроса

Объект запроса документирован в секции API. В настоящее время метод запроса доступен через использование атрибута method.
Для доступа к данным формы (данным, которые передаются в запросах типа POST
или PUT), вы можете использовать атрибут form.
```python
from flask import request

@app.route('/login', methods=['POST', 'GET'])
def login():
	error = None
	if request.method == 'POST':
		if valid_login(request.form['username'],
			request.form['password']):
			return log_the_user_in(request.form['username'])
		else:
			error = 'Invalid username/password'
	# следущий код выполняется при методе запроса GET
	# или при признании полномочий недействительными
	return render_template('login.html', error=error)
```

Что произойдёт, если ключ, указанный в атрибуте form, не существует? В этом случае будет возбуждена специальная ошибка KeyError. Вы можете перехватить её подобно стандартной KeyError, но если вы этого не сделаете, вместо этого будет показана страница с ошибкой HTTP 400 Bad Request. Так что во многих ситуациях вам
не придётся иметь дело с этой проблемой.

Для доступа к параметрам, представленным в URL (?ключ=значение), вы можете
использовать атрибут args:
```python
searchword = request.args.get('key', '')
```

# Загрузка файлов на сервер
В Flask обработка загружаемых на сервер файлов является несложным занятием. Просто убедитесь, что вы в вашей HTML-форме не забыли установить атрибут enctype="multipart/form-data", в противном случае браузер вообще не передаст
файл.
Загруженные на сервер файлы сохраняются в памяти или во временной папке внутри файловой системы. Вы можете получить к ним доступ, через атрибут объекта
запроса files. Каждый загруженный файл сохраняется в этом словаре. Он ведёт себя
так же, как стандартный объект Python file, однако он также имеет метод save(),
который вам позволяет сохранить данный файл внутрь файловой системы сервера.
Вот простой пример, показывающий, как это работает:
```python
from flask import request

@app.route('/upload', methods=['GET', 'POST'])
def upload_file():
	if request.method == 'POST':
		f = request.files['the_file']
		f.save('/var/www/uploads/uploaded_file.txt')
```
Если вы хотите до загрузки файла в приложение узнать, как он назван на стороне
клиента, вы можете просмотреть атрибут filename. Однако, имейте в виду, что данному значению никогда не стоит доверять, потому что оно может быть подделано.

Если вы хотите использовать имя файла на клиентской стороне для сохранения файла на сервере, пропустите его через функцию secure_filename(), которой вас снабдил
Werkzeug:
```python
from flask import request
from werkzeug import secure_filename

@app.route('/upload', methods=['GET', 'POST'])
def upload_file():
	if request.method == 'POST':
		f = request.files['the_file']
		f.save('/var/www/uploads/' + secure_filename(f.filename))
```

# Cookies
Для доступа к cookies можно использовать атрибут cookies. Для установки cookies
можно использовать метод объектов ответа set_cookie. Атрибут объектов запроса
cookies - это словарь со всеми cookies, которые передаёт клиент. Если вы хотите
использовать сессии, то не используйте cookies напрямую, вместо этого используйте
во Flask Сессии, который при работе с cookies даст вам некоторую дополнительную
безопасность.

Чтение cookies:
```python
from flask import request

@app.route('/')
def index():
	username = request.cookies.get('username')
	# Чтобы не получить в случае отсутствия cookie ошибку KeyError
	# используйте cookies.get(key) вместо cookies[key]
```
Сохранение cookies:
```python
from flask import make_response

@app.route('/')
def index():
	resp = make_response(render_template(...))
	resp.set_cookie('username', 'the username')
	return resp
```
Заметьте, что cookies устанавливаются в объектах ответа. Так как вы обычно просто
возвращаете строки из функций представления, Flask конвертирует их для вас в
объекты ответа. Если вы это хотите сделать явно, то можете использовать функцию,
make_response(), затем изменив её.

# Ошибки перенаправления
Чтобы перенаправить пользователя в иную конечную точку, используйте функцию
redirect(); для того, чтобы преждевременно прервать запрос с кодом ошибки, используйте функцию abort() function:
```python
from flask import abort, redirect, url_for

@app.route('/')
def index():
	return redirect(url_for('login'))

@app.route('/login')
def login():
	abort(401)
	this_is_never_executed()
```
Это довольно бессмысленный пример, потому что пользователь будет перенаправлен
с индексной страницы на страницу, на которую у него нет доступа (401 означает
отказ в доступе), однако он показывает, как это работает.

По умолчанию, для каждого кода ошибки отображается чёрно-белая страница с
ошибкой. Если вы хотите видоизменить страницу с ошибкой, то можете использовать
декоратор errorhandler():
```python
from flask import render_template

@app.errorhandler(404)
def page_not_found(error):
	return render_template('page_not_found.html'), 404
```
Обратите внимание на 404 после вызова render_template(). Это сообщит Flask, что
код статуса для этой страницы должен быть 404, что означает «не найдено». По
умолчанию предполагается код «200», который означает «всё прошло хорошо».

# Об ответах
Возвращаемое из функции представления значение автоматически для вас конвертируется вас в объект ответа. Если возвращаемое значение является строкой, оно конвертируется в объект ответа в строку в виде тела ответа, код статуса 200 OK и в mimetype со значением text/html. 

Если вы хотите в результате ответа заполучить объект внутри представления, то
можете использовать функцию make_response().
```python
@app.errorhandler(404)
def not_found(error):
	return render_template('error.html'), 404
```
Вам надо всего лишь обернуть возвращаемое выражение функцией make_response()
и получить объект ответа для его модификации, а затем вернуть его:
```python
@app.errorhandler(404)
def not_found(error):
	resp = make_response(render_template('error.html'), 404)
	resp.headers['X-Something'] = 'A value'
	return resp
```

# Сессии
В дополнение к объекту ответа есть ещё один объект, называемый session, который
позволяет вам сохранять от одного запроса к другому информацию, специфичную
для пользователя. Это реализовано для вас поверх cookies, при этом используется
криптографическая подпись этих cookie. Это означает, что пользователь может посмотреть на содержимое cookie, но не может ничего в ней изменить, если он конечно не знает значение секретного ключа, использованного для создания подписи.
В случае использования сессий вам необходимо установить значение этого секретного ключа. 
Вот как работают сессии:
```python
from flask import Flask, session, redirect, url_for, escape, request

app = Flask(__name__)

@app.route('/')
def index():
	if 'username' in session:
		return 'Logged in as %s' % escape(session['username'])
	return 'You are not logged in'

@app.route('/login', methods=['GET', 'POST'])
def login():
	if request.method == 'POST':
		session['username'] = request.form['username']
		return redirect(url_for('index'))
	return  '''
				<form action="" method="post">
					<p><input type=text name=username>
					<p><input type=submit value=Login>
				</form>
			'''
			
@app.route('/logout')
def logout():
	# удалить из сессии имя пользователя, если оно там есть
	session.pop('username', None)
	return redirect(url_for('index'))

# set the secret key. keep this really secret:
app.secret_key = 'A0Zr98j/3yX R~XHH!jmN]LWX/,?RT'
```
Упомянутая escape() осуществляет для вас обработку специальных последовательностей (escaping), что необходимо, если вы не используете движок шаблонов (как в этом примере).

***Как генерировать хорошие секретные ключи***
Проблемой случайных значений является то, что трудно сказать, что действительно
является является случайным. А секретный ключ должен быть настолько случай-
ным, насколько это возможно. У вашей операционной системы есть способы для
генерации достаточно случайных значений на базе криптографического случайного
генератора, который может быть использован для получения таких ключей:
```python
import os
my_secret_key = os.urandom(24)
```

# Логгирование

```python
app.logger.debug('Значение для отладки')
app.logger.warning('Предупреждение: (%d яблок)', 42)
app.logger.error('Ошибка')
```























































































# Добавляем переменную в виртуальное окружение

	export FLASK_APP="app.py"

Выставим режим DEBUG для того чтобы изменения сразу отображались на сервере

	export FLASK_DEBUG=1

или 

```python
if __name__ == "__main__":
	app.run(debug=True)
```

# Запуск сервера из cmd
Запускать следует из рабочей директории!

